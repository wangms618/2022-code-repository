# 官方中文文档总结

## 控制器
----
> 控制器负责**处理传入的请求**和**向客户端返回响应**
为了创建一个基本的控制器，要使用类和装饰器

### 路由
----

- 使用`@Controller()`装饰器定义一个基本的控制器，控制器中可以设置路由路径前缀
- 在`@Controller()` 装饰器中使用路径前缀可以使我们轻松地对一组相关的路由进行分组，并最大程度地减少重复代码。
```ts
/* cats.controller.ts */

import { Controller, Get } from '@nestjs/common';
// 路由前缀'cats'
@Controller('cats')
export class CatsController {
  // 发Get请求，带上/mimi路径
  @Get('mimi')
  findAll(): string {
    return 'This action returns all cats';
  }
}
// 路径前缀cats与装饰器@Get('mimi)组合生成路由映射 GET /cats/mimi
```
在上面的示例中，对此端点发`Get`请求时，Nest会将请求路由到我们定义的`findAll()`方法，这个`findAll()`方法没有任何的附加意义，与路由无关，也就是说把他改成`findSome()`等任意名字都可以。
> 创建控制器 `$ nest g controller cats`

### Request
处理程序有时需要访问客户端的请求细节。Nest 提供了对底层平台（默认为 Express）的请求对象（request）的访问方式。我们可以在处理函数的签名中使用 @Req() 装饰器，指示 Nest 将请求对象注入处理程序。
```ts
/* cats.controller.ts */

import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}
```
Request 对象代表 HTTP 请求，并具有查询字符串，请求参数参数，HTTP 标头（HTTP header） 和 正文（HTTP body）的属性（在这里阅读更多）。在多数情况下，不必手动获取它们。 我们可以使用专用的装饰器，比如开箱即用的 @Body() 或 @Query() 。 下面是 Nest 提供的装饰器及其代表的底层平台特定对象的对照列表。
> 这里只列一些常用的  

| 装饰器 | 请求参数 |
| :-----| ----: |
| @Param(key?: string) | req.params/req.params[key] |
| @Body(key?: string) | req.body/req.body[key] |
| @Query(key?: string)| req.query/req.query[key] |

其中`@Param`常用于`@Get`传递参数,`@Body`用于`@Post`传递`Body`

### 资源
