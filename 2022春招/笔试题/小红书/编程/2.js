// 薯队长写了n篇笔记，编号从1~n,每篇笔记都获得了不少点赞数。
// 薯队长想从中选出一些笔记，作一个精选集合。挑选的时候有两个规则：
//  1.不能出现连续编号的笔记。
// 2.总点赞总数最多
// 如果满足1，2条件有多种方案，挑选笔记总数最少的那种
// 输入包含两行。第一行整数n表示多少篇笔记。 第二行n个整数分别表示n篇笔记的获得的点赞数。
//  （0<n<=1000,    0<=点赞数<=1000)


// 确定动态规划，每次统计最大点赞数
// dp[i]表示在下标0-i区间，点赞数最多的情况
// dp[i]怎么可得呢，dp[i]有第i本书的情况下，dp[i] = dp[i-2] + arr[i],
// dp[i]在不需要第i本书的情况下，dp[i] = dp[i-1][]
// dp[i] = Math.max(dp[i-2]+arr[i],dp[i-1])
// 初始化 dp[0]为0 dp[1]为arr[1]
function book(n, arr) {
    // 初始化dp数组
    let dp = []
    dp[0] = arr[0]
    dp[1] = Math.max(arr[0], arr[1])
    let res = 1
    for (let i = 2; i < n; i++) {
        if (dp[i - 2] + arr[i] > dp[i - 1]) {
            dp[i] = dp[i - 2] + arr[i]
            res++
        } else {
            dp[i] = dp[i - 1]
        }
    }
    return [res, dp[n - 1]]
}
console.log(book(5, [1, 2, 3, 1, 2]));