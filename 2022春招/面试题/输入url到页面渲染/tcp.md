# TCP
1. 面向有连接
2. 在数据传输过程中通过各种算法保证数据的可靠性
3. 有拥塞控制

# TCP头部字段
1. Sequence number,保证通过tcp传输的报文都是有序的，对端可以通过序号的顺序拼接报文
  用于标识从发送端发出的不同的TCP数据段的序号。数据段在网络中传输时，它们的顺序可能会发生变化；接收端依据此序列号，便可按照正确的顺序重组数据。

2. Acknowledge Number, 表示数据接收端期望接收的下一个字节编号是多少，同时也表示上一个序号的数据已经接收到了
  32位确认序列号：用于标识接收端确认收到的数据段。确认序列号为成功收到的数据序列号加1。

  
3. Window Size, 窗口大小表示还能接收多少数据用于流量控制
16位窗口大小：表示接收端期望通过单次确认而收到的数据的大小。由于该字段为16位，所以窗口大小的最大值为65535字节，该机制通常用来进行流量控制。

4. 标识符 
  - URG=1: 该字段是本数据包里面紧急信息，是一个高优先级的报文
  - ACK=1: 该字段表示确认号字段有效
  - PSH=1: 该字段表示数据应该立即push给应用层
  - RST=1: 表示TCP连接出现问题，可能需要重连
  - SYN=1: 当SYN等于1,ACK=0时，表示报文段是一个连接请求；当SYN=1，ACK=1时，同意建立连接的应答报文
  - FIN=1: 释放连接的请求 

# 三次握手
  <!-- SYN-SENT -->
  客户端向服务端发送请求报文，发出请求SYN=1，同时选择一个初始序号 seq=x 
  <!-- LISTEN -> SYNC-RCVD -->
  客户端状态变成 **ESTABLISHED** 
  <!-- 我就在这附近工作，住的也不远 -->
  客户端接收到服务端的TCP建立验证请求后，向服务端给出确认
  服务端状态：建立连接 **ESTABLISHED**

# 为什么TCP建立连接需要三次握手，明明两次就可以建立连接
假如客户端发送一个连接请求，发送时网络出问题，导致超时重传，如果在这个过程中客户端断开了，服务端在一段时间后接收到了连接请求，而客户端确已经关闭，这就造成了连接资源的浪费，因此需要三次握手来确认客户端的实时性。

# 四次挥手
客户端向服务端发出连接释放报文，并且停止发送数据

服务器接收到连接释放报文之后，发出确认报文

客户端进入FIN-WAIT-2 
服务器把最后的信息发送完毕，就向客户端连接释放报文

客户端状态：TIME_WAIT
客户端接收到服务端发出的连接释放报文后，必须发出确认
服务端状态：CLOSED
客户端等待2MSL -> CLOSED

# 为什么客户端要进入 TIME_WAIT状态，等待2MSL时间后才进入CLOSED状态呢？
1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达


