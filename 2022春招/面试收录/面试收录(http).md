总结文章
春招临近，笔者近期也开始整理并复习前端知识点，本篇是HTTP的部分总结
# 面试总结（一）浏览器相关
## 1. HTTP和HTTPS的区别
1. `HTTP`是超文本传输协议，信息是明文传输，`HTTPS`则是具有安全性的ssl加密传输协议。
2. 一般而言，`HTTP`协议的端口为80，HTTPS的端口为443。
3. `HTTP`的连接很简单，是无状态的；HTTPS协议是由`SSL+HTTP`协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。


## 2. HTTPS是怎样工作的
1. 客户端使用`HTTPSUrl`去访问服务器
2. 服务器返回网站的证书（证书中包含了**公钥**）给客户端
3. 客户端与服务器协商`SSL`链接的安全等级，也就是加密等级
4. 客户端建立**会话密钥**，使用之前服务器返回的**公钥**来**加密会话密钥**（也就是说**会话密钥**是由公钥加密的），客户端加密完成后会将它传给服务器
5. 服务器通过自己的**私钥**解密出被公钥加密后的**会话密钥**
6. 服务器通过**会话密钥**加密与客户端之间的通信 
- 总结：客户端访问服务器，服务器返回网站的证书，证书中包含了**公钥**，客户端与服务器协商好`SSL`的安全等级后，会**建立会话密钥**，再**通过公钥来加密会话密钥**，然后传给服务器，服务器收到加密的会话密钥后，通过自己的**私钥解密被公钥加密的会话密钥**得到会话密钥，最后服务器通过会话**密钥加密与客户端的通信**。
## 3. HTTPS的优点与缺点
优点
1. 比`HTTP`更加安全
2. 使用`HTTPS`协议可认证用户和服务器，确保数据发送到正确的客户机和服务器

缺点
1. HTTPS握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。
2. SSL证书也需要钱，功能越强大的证书费用越高。 

## 4. TCP三次握手
1. 客户端向服务器发起第一次握手，**服务器**收到后**确认自己可以收到客户端传来的报文段**
2. 服务器向客户端发起第二次握手，**客户端**收到后**确认服务器可以收到自己的报文段，也确认自己可以接收到服务器传来的报文段**
3. 客户端向服务器发起第三次握手，**服务器**收到后**确认客户端可以收到自己传的报文**

## 5. 为什么TCP两次握手不行
如果不执行第三次握手，服务器就不知道客户端是否可以接收到自己传的报文，如果客户端第二次握手有较大延迟，那么当服务器接收到第二次握手时，客户端这时很有可能已经不接收服务器传送的报文了，而服务器依旧会传报文给客户端，这就造成了性能损耗，所以需要三次握手来证明客户端可以接受服务器传来的报文

## 6. TCP四次挥手
1. 第一次挥手，客户端发送一个`FIN`，告诉服务器它不再发送数据给服务器，但此时客户端还可以接收数据。
2. 第二次挥手，服务器回应一个标识了`ACK`的数据段，作为对客户端的`FIN`报文的确认，此时服务器数据还可以发送给客户端。
3. 第三次挥手，服务器发送一个`FIN`，用来关闭服务器到客户端的数据传送。
4. 第四次挥手，客户端收到`FIN`后，返回一个`ACK`给服务器(此时`TCP`连接还没有释放，必须等待**2MSL**后再进入`CLOSED`状态)，作为对服务器的`FIN`报文的确认。

### 为什么客户端最后还要等待2MSL？
原因：确保客户端发送的最后一个`ACK`报文能够到达服务器，因为如果`ACK`报文没有到达服务器，服务器会重传一个`FIN`，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

### 为什么建立连接三次握手，关闭连接是四次挥手呢？
原因：因为关闭连接时，服务器收到对方的`FIN`报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送`FIN`报文给对方来表示同意现在关闭连接，因此，己方`ACK`和`FIN`一般都会分开发送，从而导致多了一次。


## 7. TCP和UDP的区别
1. `TCP`是面向连接的可靠传输，而`UDP`是无连接的不可靠传输
1. `TCP`提供可靠的服务，通过`TCP`连接传送的数据，无差错，不丢失，不重复，且按序到达；`UDP`是尽最大努力交付，即不保证可靠交付。
2. `TCP`是面向字节流，`UDP`面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如`IP`电话和视频会议等）。
3. `TCP`只能是1对1的，UDP支持1对1,1对多。
4. `TCP`的首部较大为20字节，而`UDP`只有8字节。



## 8. HTTP2.0的新特性
1. **内容安全**，使用`HTTP2.0`可以避免单纯使用`HTTPS`的性能下降，因为`HTTP2.0`是基于`HTTPS`的
2. **二进制格式**，之前的`HTTP`解析是基于文本的，`HTTP2.0`将所有的传输信息分割为更小的消息和帧，对他们采用二进制格式编码
3. **多路复用**，这个功能相当于是长连接的增强，每个`request`请求可以随机的混杂在一起，接收方可以根据`request`的`id`将`request`再归属到各自不同的服务端请求里面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输
4. **头部压缩**
5. **设置请求优先级**
6. **服务器推送**

## 9. HTTP3.0的新特性
1. 在传输层使用`UDP`替代了`TCP`
2. 实现了一套新的拥塞控制算法，彻底解决`TCP`中队头阻塞的问题
3. 实现了快速握手功能。由于`QUIC`是基于`UDP`的，所以`QUIC`可以实现使用`0-RTT`或者`1-RTT`来建立连接，这意味着`QUIC`可以用最快的速度来发送和接收数据。
4. 集成了`TLS`加密功能。目前`QUIC`使用的是`TLS1.3`

为什么`HTTP3.0`要用`UDP`，`UDP`不是不可靠的吗？  
答：实际上`HTTP3.0`使用的是`QUIC`，`QUIC`是基于`UDP`的，`QUIC`在`UDP`的基础之上增加了一层来保证数据可靠性传输，它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。

### QUIC协议功能
1. 实现了类似`TCP`的流量控制、传输可靠性的功能
2. 集成了`TLS`加密功能
3. 实现了`HTTP2.0`中多路复用功能
4. 实现了快速握手功能

### 存在挑战
1. 部分设备对`UDP`的优化程度远低于`TCP`
2. 服务器和浏览器端对`HTTP3.0`都没有比较完整的支持
3. 系统对`UDP`的优化还不是很好
   
## 10. 进程和线程的关系
1. 每个进程有独立的一块内存，进程之间相互独立
2. 多个线程在进程中协作完成任务
3. 一个进程由多个线程构成，同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
4. 进程是**CPU资源分配的最小单位**（是能拥有资源和独立运行的最小单位）
5. 线程是**CPU调度的最小单位**（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程），执行一串指令所需要的时间
6. 不同进程之间也可以通信，不过代价较大
7. 进程和线程是对某`CPU`个时间段做的事的描述

## 11. Cookie、sessionStorage、localStorage的区别
共同点：都是保存在浏览器端，并且是同源的
不同点：
1. `Cookie`的存储大小只有4k左右，`sessionStorage`、`localStorage`虽然也有存储大小的限制，但是比`Cookie`大得多，可以达到5M或更大
2. `Cookie`数据始终在同源的`HTTP`请求中携带(即使不需要)，即`cookie`在浏览器和服务器间来回传递，`sessionStorage`、`localStorage`仅在客户端即浏览器中保存，不参与和服务器的通信
3. 数据的有效期不同  
`sessionStorage`：仅在当前的浏览器窗口关闭有效  
`localStorage`：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据  
`cookie`：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭
4. 作用域不同  
`sessionStorage`：不在不同的浏览器窗口中共享，即使是同一个页面  
`localStorage`：在所有同源窗口都是共享的  
`cookie`：也是在所有同源窗口中共享的
5. `Cookie`需要程序员自己封装，原生的`cookie`接口不友好；`sessionStorage`、`localStorage`可采用原生接口，亦可再次封装

## 12. js单线程有什么优势？
1. 提高效率
2. 节省运行内存
3. 减少上下文切换的时间

## 13. 如果一个页面加载很慢，你觉得是什么原因
1. 有可能是页面上的图片过多，解决应该用懒加载
2. 页面流量过大，超载了
3. HTTP请求过多，没有合理的使用缓存，应该减少HTTP请求

## 14. iframe是什么？有什么缺点？
定义：iframe元素会创建包含另一个文档的内联框架  
缺点：
1. 会阻塞主页面的onload事件
2. 搜索引擎无法解读这种页面，不利于SEO
3. iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

## 15. Cookie和session的区别
1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗
考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用cookie。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

## 16. Cookie如何防范XSS攻击
在HTTP头部上配置set-cookie  
有两个属性可以防止XSS攻击:  
HTTPonly：这个属性可禁止JavaScript访问Cookie，故可以保护Cookie不被嵌入的恶意代码所获取  
secure - ：这个属性告诉客户端浏览器仅当在HTTPS请求时发送Cookie
> response.setHeader("Set-Cookie","cookiename=HTTPonlyTest;Path=/ ;Domain=domainvalue;Hax-Age=seconds;HTTPOnly")

## 17. 移动端300ms延迟的原因及如何解决？
原因：由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，看用户有没有下一次点击，也就是这次操作是不是双击。
解决：
1. 禁用缩放。`<meta name="viewport" content="width=device-width, user-scalable=no">`
2. 利用FastClick，检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉

## 18. 怎么理解HTTP状态码
1xx: 信息性状态码，接收的请求正在处理
2xx: 成功状态码，请求正常处理完毕
3xx: 重定向状态码，需要进行附加操作以完成请求  
4xx: 客户端错误状态码，服务器无法处理请求
5xx: 服务器错误状态码，服务器处理请求出错

## 19. 一些常见的状态码
1. 200 OK 表示客户端发来的请求在服务器端被正常处理了
2. 204 No Content 服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
3. 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求
4. 301 Moved Permanently 永久性重定向。表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI
5. 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI,且资源只是临时被移动，希望本次使用新的URI访问，但客户端还是可以使用原有URI访问对应资源
6. 303 See Other 表示请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。(301、302、303响应状态码返回时，几乎所有浏览器都会把POST改成GET，但301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。)
7. 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源，可直接使用客户端未过期的缓存
8. 307 Temporary Redirect 临时重定向。与302类似。但是307会遵守浏览器标准，不会从POST变成GET。
9. 400 Bad Request 客户端请求的语法错误，服务器无法理解
10. 401 Unauthorized 请求要求用户的身份认证，若之前已经进行过一次请求，则表示用户认证失败
11. 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求，未获得文件系统的访问授权，访问权限出现某些问题都是可能发生403的原因
12. 404 Not Found 服务器上无法找到请求的资源
13. 500 Internal Server Error 服务器内部错误，无法完成请求
14. 503  Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
## 20. 强缓存与协商缓存
### **强缓存**
**Expires(HTTP1.0)**  
- HTTP1.0 使用Expires(**过期时间**),存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。  
缺点：服务器与浏览器时间不一致

**Cache-Control(HTTP1.1)**  
- HTTP1.1使用Cache-Control，它采用**过期时长**来控制缓存，对应的字段是max-age  

**当Expires和Cache-Control都存在时，优先用Cache-Control**

### **协商缓存**  
强缓存失效之后，**浏览器在请求头中携带相应的缓存tag来向服务器发请求**，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。

**Tag: Last-Modified 和 ETag。**

**Last-Modified: 最后修改时间**  
浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。  
服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中该资源的最后修改时间对比:  
如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。  
否则返回304，告诉浏览器直接用缓存。  
优点：性能优于ETag  
缺点：  
  1. 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  2. `Last-Modified` 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 `Last-Modified` 并没有体现出修改了。
  3. 不能精准感知资源变化。  


**ETag**：`ETag`是根据服务器当前文件内容给文件生成的唯一标识，下次请求时将这个值作为`if-None-Match`这个字段的内容放入到请求头中发给服务器对比，如果不一样则更新，返回200，一样则返回304，告诉浏览器直接用缓存 


**服务器优先考虑ETag**


**对浏览器的缓存机制来做个简要的总结:**
1. 首先通过 **Cache-Control** 验证强缓存是否可用
2. 如果强缓存可用，直接使用
3. 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的**If-Modified-Since**或者**If-None-Match**字段检查资源是否更新
4. 若资源更新，返回资源和200状态码
5. 否则，返回304，告诉浏览器直接从缓存获取资源。
## 21. GET和POST的区别
1. get参数通过url传递，post放在request body中。
2. get请求在url中传递的参数是有长度限制的，而post没有。
3. get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
4. get请求只能进行url编码，而post支持多种编码方式
5. get请求会浏览器主动cache，而post支持多种编码方式。
6. get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
7. GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
8. GET产生一个TCP数据包；POST产生两个TCP数据包。

## 22. HTTP支持的方法
HTTP/1.1规定了以下请求方法(注意，都是大写): 
- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源(几乎用不到)
- CONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径


## 23. 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？
DNS解析
TCP连接
发送HTTP请求
服务器处理请求并返回HTTP报文
浏览器解析渲染页面
连接结束

具体细节参考这篇文章
HTTPS://juejin.cn/post/6844903832435032072

## 24. CSRF和XSS是什么？怎么防御
XSS：跨站脚本攻击
发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码。实际上是在目标网站的作用域下执行了这段js代码。  
XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的XSS攻击。  
CSRF：跨站请求伪造
在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。  
防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。


## DNS劫持
DNS劫持指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应。

## 说说什么是跨域？如何解决？
首先要知道浏览器有同源策略，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。同源指的是是指"协议+域名+端口"三者相同。不同源之间的页面，不准互相访问数据。**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。**
### 1. JSONP
借助script标签不会被同源机制所跨域，客户端发送script请求，参数中带着处理返回数据的回调函数，服务端接收到请求，并帮助执行掉这个回调函数。  
缺点：
1. 由于是借助script脚本请求方式，所以只适用于get请求
2. 调用失败不会返回各种HTTP状态码
3. 安全性不高，jsonp的服务存在页面注入的漏洞


### 为什么HTTP3.0要用UDP协议
首先，我们要知道TCP协议与UDP协议的区别([本文第七题](xxx))，了解完后我们来分析为什么HTTP3.0是用UDP协议。
#### 1. HTTP/2 和 TCP 的缺陷
1. 建立连接时间长(本质上是TCP的问题，需要深入了解的同学可以阅读这篇文章[链接地址](HTTPS://zhuanlan.zhihu.com/p/377467248))
2. 队头阻塞问题。只要出现丢包，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。
3. 移动互联网领域表现不佳(弱网环境)

#### 2. HTTP3.0做了什么
首先我们要明确，HTTP3.0并不是直接使用的UDP，而是在UDP基础上改造的一个具备 TCP协议优点的新协议(QUIC)
1. QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。



  












### 为什么HTTP2.0