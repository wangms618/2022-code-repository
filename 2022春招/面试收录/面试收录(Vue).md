# vue怎样实现数据响应式
当key对应的数据被修改时，Vue它要知道该去通知哪些数据也要发生改变，所以我们要把所有该页面上用到该对象中同一key加入到让它通知的名单里面就好像是一起订阅了，数据变化就发布，所有订阅者将会同时刷新。

Vue2响应式原理
	1. 先构建一个observer(target)观察者函数，参数接收数据源data里的对象
Observer函数：
一、 先判断传入的是否是对象，如果是对象再判断是否是数组，如果是数组重写数组原型即可
二、 写一个for in 循环去检测data里所有的对象 
三、 在fon in里利用劫持函数去劫持对象的每一个属性

劫持函数defineReactive(target, key, value)：传入三个参数，对象，对象的键，键对应的值，进入后先做判断，键对应的值是否是对象，如果是对象，再将这个值传入Observer观察者函数进行递归，如果不是，利用Object.defineProperty做数据劫持，在set函数中修改数据源和视图，实现响应式

重写数组原型：拿到数组的原型上的所有属性( Array.prototype)赋值给一个变量(oldArrayPrototype)，将这个变量拿去深拷贝生成新对象(防止修改到原数组上的属性)，接着重写这个变量的属性，也就是重写数组方法，在每个数组方法里都放入视图更新函数，实现了数组的响应式，当然这只能是数组使用方法时进行更新，如果数组只是利用下标去修改，则不会更新


Vue2的响应式是基于Object.defineProperty实现的
Vue3的响应式是基于ES6的Proxy来实现的

Vue2 弊端：
Object.defineProperty只对初始对象里的属性有监听作用，而对新增的属性无效（新增属性不会更新）。这也是为什么Vue2中对象新增属性的修改需要使用Vue.$set来设值的原因。
 2.0 默认递归，用不用都递归 3.0只有取值的那一刻才递归
改变数组的length属性是无效的
对象不存在的属性是不能被劫持的



问题，如果数据源里对象里又放了对象，怎么去劫持
答：递归
数组是响应式吗？vue当中是怎么实现让数组也实现响应式

为什么2.0实现不了新增，因为Object.defineProperty里的set只有newVal
3.0中Proxy中set参数多了target和key，target代表对象，对象当前的键名

Vue3 里用WeakMap来存已经代理过的对象，防止已经被代理过的对象被二次代理，为什么用WeakMap，因为他不会被垃圾回收掉，被代理过的对象会被保留
缺点：兼容性不行，不能兼容到IE11 
